{"mappings":"CCEC,AAAA,WAKC,SAAS,EAAK,CAAO,EACnB,GAAM,CAAA,OAAE,EAAS,QAAQ,GAAG,CAAC,IAAI,CAAC,QAAA,CAAA,MAAU,CAAK,CAAE,CAAG,CACzC,CAAA,EAAK,IAAI,CAItB,IAAI,EAAS,IAAI,OAAO,IAAI,IAAI,yCAEhC,QAAQ,GAAG,CAAC,aAAc,GAE1B,IAAM,EAAY,CAAC,EACf,EAAa,EAEX,EAAc,SAAU,CAAE,CAAE,CAAE,EAClC,CAAS,CAAC,EAAG,CAAG,EAChB,GAAc,CAChB,EAEM,EAAe,SAAU,CAAE,CAAE,CAAG,CAAE,CAAG,EACzC,IAAM,EAAK,CAAS,CAAC,EAAG,CACpB,IACF,OAAO,CAAS,CAAC,EAAG,CACpB,EAAG,EAAK,IAIS,GAFnB,CAAA,GAAc,CAAA,GAGZ,WAAW,WAGM,OAAX,GAAmB,AAAe,IAAf,IACrB,QAAQ,GAAG,CAAC,qBAEZ,EAAO,SAAS,GAChB,EAAS,KAEb,EAAG,IAEP,EAEM,EAAO,CACX,KAAK,CAAQ,CAAE,CAAW,CAAE,CAAQ,EAClC,GAAI,CAAC,EACH,OAAO,EAAS,AAAI,MAAM,sBAE5B,EAAY,EAAU,GACtB,EAAO,WAAW,CAAC,CACjB,KAAM,OACN,SAAA,EACA,YAAA,CACF,EACF,EACA,KAAK,CAAQ,CAAE,CAAQ,EACrB,GAAI,CAAC,EACH,OAAO,EAAS,AAAI,MAAM,sBAE5B,EAAY,EAAU,GACtB,EAAO,WAAW,CAAC,CACjB,KAAM,OACN,SAAA,CACF,EACF,EACA,QAAQ,CAAI,CAAE,CAAQ,EACpB,GAAI,CAAC,EACH,OAAO,EAAS,AAAI,MAAM,sBAE5B,EAAY,UAAW,GACvB,EAAO,WAAW,CAAC,CACjB,KAAM,UACN,KAAA,CACF,EACF,CACF,CAEA,CAAA,EAAO,SAAS,CAAG,SAAU,CAAK,EAChC,IAAM,EAAU,EAAM,IAAI,CAE1B,OAAQ,EAAQ,IAAI,EAClB,IAAK,QACH,EAAO,gBACH,GACF,EAAM,GAER,KAGF,KAAK,SACH,EAAO,iBAAmB,EAAQ,IAAI,EACtC,KAEF,KAAK,QAAS,CACZ,IAAM,EAAW,EAAQ,QAAQ,CACjC,EAAO,UAAY,EAAW,UAC9B,EAAa,EAAU,MACvB,KACF,CAEA,IAAK,SAAU,CACb,GAAM,CAAA,SAAE,CAAQ,CAAA,YAAE,CAAW,CAAE,CAAG,EAClC,EAAO,UAAY,EAAW,YAAc,EAAY,MAAM,CAAG,KAC7D,EACF,EAAa,EAAU,KAAM,GAE7B,EAAa,EAAU,AAAI,MAAM,mBAEnC,KACF,CAEA,IAAK,WAAY,CACf,GAAM,CAAA,OAAE,CAAM,CAAE,CAAG,EACnB,EAAO,6BAA+B,GAClC,AAAW,IAAX,EACF,EACE,UACA,AAAI,MAAM,2BAA6B,IAGzC,EAAa,UAAW,MAE1B,KACF,CAEA,QACE,EAAO,wBAA0B,EAErC,CACF,CACF,CAEA,EAAK,OAAO,CAAG,SAAU,CAAA,OACvB,CAAM,CAAA,YACN,CAAW,CAAA,aACX,CAAY,CAAA,cACZ,CAAa,CAAA,UACb,CAAS,CAAA,SACT,CAAQ,CACT,EACC,IAAM,EAAe,SAAU,CAAG,CAAE,CAAG,EACjC,GACE,CAAA,GAAO,CAAA,IACT,EAAS,EAAK,GACd,EAAW,KAGjB,EACA,EAAK,CACH,OAAA,EACA,MAAO,SAAU,CAAI,EACnB,EAAK,IAAI,CAAC,YAAa,EAAa,GACpC,EAAK,OAAO,CACV,CACE,YACA,GAAgB,GAChB,GAAiB,GACjB,OAAO,GAAa,KACpB,KACA,YACA,aACD,CACD,GAEF,EAAK,IAAI,CAAC,aAAc,EAC1B,CACF,EACF,EAEA,EAAK,IAAI,CAAG,SAAU,CAAM,EAC1B,EAAK,CACH,OAAA,EACA,MAAO,SAAU,CAAI,EACnB,EAAK,OAAO,CAAC,CAAC,SAAS,CACzB,CACF,EACF,EAEA,EAAK,mBAAmB,CAAG,SAAU,CAAM,EACzC,IAAM,EAAS,OAAO,IAAI,CAAC,GACrB,EAAM,EAAO,MAAM,CACnB,EAAQ,IAAI,WAAW,GAC7B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,IACvB,CAAK,CAAC,EAAE,CAAG,EAAO,UAAU,CAAC,GAE/B,OAAO,EAAM,MAAM,AACrB,EAEA,EAAK,mBAAmB,CAAG,SAAU,CAAM,EACzC,IAAI,EAAS,GACP,EAAQ,IAAI,WAAW,GACvB,EAAM,EAAM,UAAU,CAC5B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,IACvB,GAAU,OAAO,YAAY,CAAC,CAAK,CAAC,EAAE,EAExC,OAAO,OAAO,IAAI,CAAC,EACrB,EAEA,OAAO,IAAI,CAAG,CAChB","sources":["<anon>","src/qpdf.js"],"sourcesContent":["var $91a917a299f8d641$exports = {};\n/* eslint-env browser */ (function() {\n    // The QPDF Module\n    // let worker = new Worker(new URL(\"http://localhost:3000/qpdf-worker.js\"));\n    function QPDF(options) {\n        const { logger: logger = console.log.bind(console), ready: ready } = options;\n        const path = QPDF.path || \"\";\n        // let worker = new Worker(path + \"qpdf-worker.js\");\n        let worker = new Worker(new URL(\"http://localhost:3000/qpdf-worker.js\"));\n        console.log(\"new worker\", worker);\n        const listeners = {};\n        let nListeners = 0;\n        const addListener = function(id, fn) {\n            listeners[id] = fn;\n            nListeners += 1;\n        };\n        const callListener = function(id, err, arg) {\n            const fn = listeners[id];\n            if (fn) {\n                delete listeners[id];\n                fn(err, arg);\n            }\n            nListeners -= 1;\n            if (nListeners === 0) setTimeout(function() {\n                // No new commands after 1 second?\n                // Then we terminate the worker.\n                if (worker !== null && nListeners === 0) {\n                    console.log(\"worker terminated\");\n                    worker.terminate();\n                    worker = null;\n                }\n            }, 1000);\n        };\n        const qpdf = {\n            save (filename, arrayBuffer, callback) {\n                if (!worker) return callback(new Error(\"worker terminated\"));\n                addListener(filename, callback);\n                worker.postMessage({\n                    type: \"save\",\n                    filename: filename,\n                    arrayBuffer: arrayBuffer\n                });\n            },\n            load (filename, callback) {\n                if (!worker) return callback(new Error(\"worker terminated\"));\n                addListener(filename, callback);\n                worker.postMessage({\n                    type: \"load\",\n                    filename: filename\n                });\n            },\n            execute (args, callback) {\n                if (!worker) return callback(new Error(\"worker terminated\"));\n                addListener(\"execute\", callback);\n                worker.postMessage({\n                    type: \"execute\",\n                    args: args\n                });\n            }\n        };\n        worker.onmessage = function(event) {\n            const message = event.data;\n            switch(message.type){\n                case \"ready\":\n                    logger(\"[qpdf] ready\");\n                    if (ready) ready(qpdf);\n                    break;\n                case \"stdout\":\n                    logger(\"[qpdf.worker] \" + message.line);\n                    break;\n                case \"saved\":\n                    {\n                        const filename = message.filename;\n                        logger(\"[qpdf] \" + filename + \" saved\");\n                        callListener(filename, null);\n                        break;\n                    }\n                case \"loaded\":\n                    {\n                        const { filename: filename, arrayBuffer: arrayBuffer } = message;\n                        logger(\"[qpdf] \" + filename + \" loaded (\" + arrayBuffer.length + \")\");\n                        if (arrayBuffer) callListener(filename, null, arrayBuffer);\n                        else callListener(filename, new Error(\"File not found\"));\n                        break;\n                    }\n                case \"executed\":\n                    {\n                        const { status: status } = message;\n                        logger(\"[qpdf] exited with status \" + status);\n                        if (status !== 0) callListener(\"execute\", new Error(\"QPDF exited with status \" + status));\n                        else callListener(\"execute\", null);\n                        break;\n                    }\n                default:\n                    logger(\"[qpdf] other message \" + message);\n            }\n        };\n    }\n    QPDF.encrypt = function({ logger: logger, arrayBuffer: arrayBuffer, userPassword: userPassword, ownerPassword: ownerPassword, keyLength: keyLength, callback: callback }) {\n        const safeCallback = function(err, arg) {\n            if (callback) {\n                if (err || arg) {\n                    callback(err, arg);\n                    callback = null;\n                }\n            }\n        };\n        QPDF({\n            logger: logger,\n            ready: function(qpdf) {\n                qpdf.save(\"input.pdf\", arrayBuffer, safeCallback);\n                qpdf.execute([\n                    \"--encrypt\",\n                    userPassword || \"\",\n                    ownerPassword || \"\",\n                    String(keyLength || 256),\n                    \"--\",\n                    \"input.pdf\",\n                    \"output.pdf\"\n                ], safeCallback);\n                qpdf.load(\"output.pdf\", safeCallback);\n            }\n        });\n    };\n    QPDF.help = function(logger) {\n        QPDF({\n            logger: logger,\n            ready: function(qpdf) {\n                qpdf.execute([\n                    \"--help\"\n                ]);\n            }\n        });\n    };\n    QPDF.base64ToArrayBuffer = function(base64) {\n        const binary = window.atob(base64);\n        const len = binary.length;\n        const bytes = new Uint8Array(len);\n        for(let i = 0; i < len; i++)bytes[i] = binary.charCodeAt(i);\n        return bytes.buffer;\n    };\n    QPDF.arrayBufferToBase64 = function(buffer) {\n        let binary = \"\";\n        const bytes = new Uint8Array(buffer);\n        const len = bytes.byteLength;\n        for(let i = 0; i < len; i++)binary += String.fromCharCode(bytes[i]);\n        return window.btoa(binary);\n    };\n    window.QPDF = QPDF;\n})();\n\n\n//# sourceMappingURL=index.e26b6674.js.map\n","/* eslint-env browser */\r\n\r\n(function () {\r\n  // The QPDF Module\r\n\r\n  // let worker = new Worker(new URL(\"http://localhost:3000/qpdf-worker.js\"));\r\n\r\n  function QPDF(options) {\r\n    const { logger = console.log.bind(console), ready } = options;\r\n    const path = QPDF.path || \"\";\r\n\r\n    // let worker = new Worker(path + \"qpdf-worker.js\");\r\n\r\n    let worker = new Worker(new URL(\"http://localhost:3000/qpdf-worker.js\"));\r\n\r\n    console.log(\"new worker\", worker);\r\n\r\n    const listeners = {};\r\n    let nListeners = 0;\r\n\r\n    const addListener = function (id, fn) {\r\n      listeners[id] = fn;\r\n      nListeners += 1;\r\n    };\r\n\r\n    const callListener = function (id, err, arg) {\r\n      const fn = listeners[id];\r\n      if (fn) {\r\n        delete listeners[id];\r\n        fn(err, arg);\r\n      }\r\n      nListeners -= 1;\r\n\r\n      if (nListeners === 0) {\r\n        setTimeout(function () {\r\n          // No new commands after 1 second?\r\n          // Then we terminate the worker.\r\n          if (worker !== null && nListeners === 0) {\r\n            console.log(\"worker terminated\");\r\n\r\n            worker.terminate();\r\n            worker = null;\r\n          }\r\n        }, 1000);\r\n      }\r\n    };\r\n\r\n    const qpdf = {\r\n      save(filename, arrayBuffer, callback) {\r\n        if (!worker) {\r\n          return callback(new Error(\"worker terminated\"));\r\n        }\r\n        addListener(filename, callback);\r\n        worker.postMessage({\r\n          type: \"save\",\r\n          filename,\r\n          arrayBuffer,\r\n        });\r\n      },\r\n      load(filename, callback) {\r\n        if (!worker) {\r\n          return callback(new Error(\"worker terminated\"));\r\n        }\r\n        addListener(filename, callback);\r\n        worker.postMessage({\r\n          type: \"load\",\r\n          filename,\r\n        });\r\n      },\r\n      execute(args, callback) {\r\n        if (!worker) {\r\n          return callback(new Error(\"worker terminated\"));\r\n        }\r\n        addListener(\"execute\", callback);\r\n        worker.postMessage({\r\n          type: \"execute\",\r\n          args,\r\n        });\r\n      },\r\n    };\r\n\r\n    worker.onmessage = function (event) {\r\n      const message = event.data;\r\n\r\n      switch (message.type) {\r\n        case \"ready\": {\r\n          logger(\"[qpdf] ready\");\r\n          if (ready) {\r\n            ready(qpdf);\r\n          }\r\n          break;\r\n        }\r\n\r\n        case \"stdout\":\r\n          logger(\"[qpdf.worker] \" + message.line);\r\n          break;\r\n\r\n        case \"saved\": {\r\n          const filename = message.filename;\r\n          logger(\"[qpdf] \" + filename + \" saved\");\r\n          callListener(filename, null);\r\n          break;\r\n        }\r\n\r\n        case \"loaded\": {\r\n          const { filename, arrayBuffer } = message;\r\n          logger(\"[qpdf] \" + filename + \" loaded (\" + arrayBuffer.length + \")\");\r\n          if (arrayBuffer) {\r\n            callListener(filename, null, arrayBuffer);\r\n          } else {\r\n            callListener(filename, new Error(\"File not found\"));\r\n          }\r\n          break;\r\n        }\r\n\r\n        case \"executed\": {\r\n          const { status } = message;\r\n          logger(\"[qpdf] exited with status \" + status);\r\n          if (status !== 0) {\r\n            callListener(\r\n              \"execute\",\r\n              new Error(\"QPDF exited with status \" + status)\r\n            );\r\n          } else {\r\n            callListener(\"execute\", null);\r\n          }\r\n          break;\r\n        }\r\n\r\n        default: {\r\n          logger(\"[qpdf] other message \" + message);\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  QPDF.encrypt = function ({\r\n    logger,\r\n    arrayBuffer,\r\n    userPassword,\r\n    ownerPassword,\r\n    keyLength,\r\n    callback,\r\n  }) {\r\n    const safeCallback = function (err, arg) {\r\n      if (callback) {\r\n        if (err || arg) {\r\n          callback(err, arg);\r\n          callback = null;\r\n        }\r\n      }\r\n    };\r\n    QPDF({\r\n      logger,\r\n      ready: function (qpdf) {\r\n        qpdf.save(\"input.pdf\", arrayBuffer, safeCallback);\r\n        qpdf.execute(\r\n          [\r\n            \"--encrypt\",\r\n            userPassword || \"\",\r\n            ownerPassword || \"\",\r\n            String(keyLength || 256),\r\n            \"--\",\r\n            \"input.pdf\",\r\n            \"output.pdf\",\r\n          ],\r\n          safeCallback\r\n        );\r\n        qpdf.load(\"output.pdf\", safeCallback);\r\n      },\r\n    });\r\n  };\r\n\r\n  QPDF.help = function (logger) {\r\n    QPDF({\r\n      logger,\r\n      ready: function (qpdf) {\r\n        qpdf.execute([\"--help\"]);\r\n      },\r\n    });\r\n  };\r\n\r\n  QPDF.base64ToArrayBuffer = function (base64) {\r\n    const binary = window.atob(base64);\r\n    const len = binary.length;\r\n    const bytes = new Uint8Array(len);\r\n    for (let i = 0; i < len; i++) {\r\n      bytes[i] = binary.charCodeAt(i);\r\n    }\r\n    return bytes.buffer;\r\n  };\r\n\r\n  QPDF.arrayBufferToBase64 = function (buffer) {\r\n    let binary = \"\";\r\n    const bytes = new Uint8Array(buffer);\r\n    const len = bytes.byteLength;\r\n    for (let i = 0; i < len; i++) {\r\n      binary += String.fromCharCode(bytes[i]);\r\n    }\r\n    return window.btoa(binary);\r\n  };\r\n\r\n  window.QPDF = QPDF;\r\n})();\r\n"],"names":["QPDF","options","logger","console","log","bind","ready","path","worker","Worker","URL","listeners","nListeners","addListener","id","fn","callListener","err","arg","setTimeout","terminate","qpdf","save","filename","arrayBuffer","callback","Error","postMessage","type","load","execute","args","onmessage","event","message","data","line","length","status","encrypt","userPassword","ownerPassword","keyLength","safeCallback","String","help","base64ToArrayBuffer","base64","binary","window","atob","len","bytes","Uint8Array","i","charCodeAt","buffer","arrayBufferToBase64","byteLength","fromCharCode","btoa"],"version":3,"file":"index.e26b6674.js.map"}